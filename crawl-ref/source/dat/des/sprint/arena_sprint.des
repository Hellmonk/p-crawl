{{

-- This is an arena. If you kill everything before the time limit you win gold,
-- arena points, and get some extra time to rest. Shops are very important here.
-- When the last monster spawns, you get about 60 turns before the round ends.
--
-- Difficulty ramps up quickly. The first boss (round 5) is hard if you don't
-- use items or god powers. There's enough gold at the start to get a decent
-- item or two by round 5. The first two bosses tend to die fast. Later ones
-- are a different matter.
--
-- Every fifth fight is a boss. You get a rune after them. Unlike normal rounds,
-- they will end as soon as you kill the boss. Many of them have their HP/HD
-- messed with. After round 27, bosses come every 3rd round. The reward for
-- killing a boss is an "acquire any" item.
--
-- 1/5 of all normal rounds are lightning rounds. To win, you only need to
-- survive. Killing all the monsters will be nearly impossible because of how
-- fast they spawn.
--
-- After round 27 the orb will drop, but picking it up is optional. You can do
-- so to win, or for massive arena points. Round 42 is the final one.
-- That round will give you the 10th rune if you survive, but it's designed to
-- be almost impossible without extreme tactics (like using tomb cards or quad
-- damage). It is much harder than anything you will find in a zig.
--
-- Arena points are just for style. The formula is:
--      (1 + (enemies_killed)) * (round number) * (multiplier)
-- with "multiplier" getting +1 for every round you fully clear (kill everyone)
-- and +2 for boss kills. It resets to 1 if you fail to clear a round, and 27 if
-- you are carrying the orb. Therefore, points are mostly skill, but there is
-- a substantial luck factor.
--
-- As for gold, the amount you gain is based on your score multiplier (up to
-- x5) and the current round number. Enemies killed is not a factor.
--
-- Killing all the enemies can be very hard, and a lot of luck is involved. You
-- only get about 60 turns to kill the last enemy, and it might spawn in a far
-- away spot. This is intentional.
--
-- XXX: Zin is overpowered.

function arena_sprint_is_boss_round(round_id)
    return (round_id < 27 and round_id % 5 == 0) or (round_id > 27 and round_id % 3 == 0)
end


function arena_sprint_spawn_enemies(data)
    local sp = dgn.find_marker_positions_by_prop(data.spawn_dir, 1)
    for _, pos in ipairs(sp) do
        if data.num_spawned >= data.round_enemies then
            break
        end
        if crawl.one_chance_in(#sp) then
            if arena_sprint_is_boss_round(data.round_id) and not data.boss_spawned then
                local dude = dgn.create_monster(pos.x, pos.y, data.monster_set[2])
                if dude then
                    dude.set_prop("boss_mons", 1)
                    dude.beh = mons.behaviour("wander")
                    data.num_spawned = data.num_spawned + 1
                    data.boss_spawned = true
                    dgn.apply_area_cloud(pos.x, pos.y, 10, 10, 1, 1,
                                         "translocational energy", "other", -1)
                    crawl.dpr("Spawned " .. crawl.grammar(dude.name, "a") .. " (" .. data.spawn_timer .. ").")
                end
            else
                local dude = dgn.create_monster(pos.x, pos.y, data.monster_set[1])
                if dude then
                    if dude.experience > 0 then
                        -- Plants, fungi, etc, don't count
                        dude.set_prop("arena_replica", 1)
                        data.num_spawned = data.num_spawned + 1
                    end
                    dude.beh = mons.behaviour("wander")
                    dgn.apply_area_cloud(pos.x, pos.y, 10, 10, 1, 1,
                                         "translocational energy", "other", -1)
                    crawl.dpr("Spawned " .. crawl.grammar(dude.name, "a") .. " (" .. data.spawn_timer .. ").")
                end
            end
        end
    end
end


function arena_sprint_end_round(data)
    data.between_rounds = true

    local you_x, you_y = you.pos()

    -- Place orb / rune
    if arena_sprint_is_boss_round(data.round_id) then
        crawl.mpr("A rune of Zot has appeared.", "orb")
        dgn.create_item(you_x, you_y, data.monster_set[3])
        data.time_left = 1500 + crawl.random2(500)
        if data.round_id > 27 then
            local p = dgn.find_marker_positions_by_prop("centre_point", 1)[1]
            dgn.grid(p.x, p.y, "exit_dungeon")
            if data.round_id < 42 then
                crawl.mpr("The exit has re-opened... for now.", "orb")
            else
                crawl.mpr("The exit has re-opened.", "orb")
            end
        end
    elseif data.round_id == 27 then
        crawl.mpr("The Orb of Zot has appeared in the centre of the arena!", "orb")
        local p = dgn.find_marker_positions_by_prop("centre_point", 1)[1]
        dgn.create_item(p.x, p.y, "orb of zot")
        data.time_left = 1500 + crawl.random2(500)
    end

    -- Guarantee at least 15 turns of rest
    data.time_left = data.time_left + 150

    -- Scoring
    local style_gain = (1 + data.num_killed) * data.round_id
    local gold_gain = 10 * data.round_id

    if you.have_orb() and data.style_mult < 27 then
        data.style_mult = 27
    end

    if data.num_killed >= data.round_enemies or data.lightning_round then
        data.style_mult = data.style_mult + 1
        if arena_sprint_is_boss_round(data.round_id) then
            crawl.mpr("<yellow>You have won a prize for killing the boss!</yellow>", "warning")
            -- Extra score multiplier for killing the boss.
            data.style_mult = data.style_mult + 1
            -- Reward for boss kills. Doesn't come identified...
            dgn.create_item(you_x, you_y, "acquire any")
            dgn.create_item(you_x, you_y, "potion of experience q:1")
        else
            crawl.mpr("<yellow>Victory!</yellow>", "warning")
        end
        crawl.mpr("Score multiplier: " .. data.style_mult .. "x", "intrinsic_gain")
        -- Gold multiplier is capped at 5x
        gold_gain = gold_gain * math.min(data.style_mult, 5)
    else
        if you.have_orb() and data.style_mult > 27 then
            data.style_mult = 27
            crawl.mpr("Score multiplier reset to 27x", "intrinsic_gain")
        elseif data.style_mult > 1 then
            crawl.mpr("You lost your score multiplier.", "intrinsic_gain")
            data.style_mult = 1
        end
    end

    style_gain = style_gain * data.style_mult
    local style_points = dgn.persist.arena_style_points + style_gain
    dgn.persist.arena_style_points = style_points
    if style_points > 1 then
        crawl.mpr("You now have " .. style_points .. " arena points " ..
                  "(gained " .. style_gain .. ").", "intrinsic_gain")
    else
        crawl.mpr("You now have 1 arena point.", "intrinsic_gain")
    end
    crawl.take_note("Arena points: " .. style_points ..
                    " (+" .. style_gain .. ") [x" .. data.style_mult .. "]",
                    "intrinsic_gain")

    dgn.create_item(you_x, you_y, "gold q:" .. gold_gain)

    -- This dismisses *every* monster on the entire level, including
    -- your allies.
    local gxm, gym = dgn.builder_bounds()
    for p in iter.rect_iterator(dgn.point(1, 1), dgn.point(gxm - 2, gym - 2)) do
        local dude = dgn.mons_at(p.x, p.y)
        if dude then
            dgn.apply_area_cloud(p.x, p.y, 5, 10, 1, 1,
                                 "translocational energy", "other", 10)
            dude.dismiss()
        end
    end

    if data.round_id == 42 then
        crawl.mpr("<white>The arena falls silent. Everyone but you is dead.</white>")
        crawl.mpr("<white>There is nothing to do now but take the Orb and leave.</white>")
        crawl.mpr("<white>Congratulations, champion.</white>")
        data.finished = true
    else
        data.round_id = data.round_id + 1
    end
    crawl.more()
end


function arena_sprint_ominous_countdown(time_left, waiting)
    if not waiting then
        if time_left > 0
            and (time_left == 500
                or time_left == 200
                or time_left == 150
                or time_left == 100
                or (time_left <= 50 and time_left % 10 == 0))
        then
            crawl.mpr(time_left / 10 .. "...", "duration")
        elseif time_left <= 0 then
            crawl.mpr("Time's up!", "duration")
            --crawl.more()
            crawl.mpr("The arena falls silent.")
        end
    elseif time_left == 20 and waiting then
        -- There was more of a countdown here, but it felt too spammy.
        crawl.mpr("<yellow>Get ready!</yellow>", "warning")
    end
end


function arena_sprint_get_monster_set(round, boss)
    if not boss then
        if round == 27 then
            return {"place:Sanctum:$ / orb guardian w:70 / tiamat / " ..
                       "orb of fire / electric golem / killer klown / " ..
                       "ancient lich / moth of wrath"}
        end

        local mon_set = {}

        -- First two rounds have a more limited, less lethal set.
        if round == 1 and crawl.coinflip() then
            return {"place:D:2"}
        elseif round <= 2 then
            mon_set = {
                "rat"
            }
        elseif round <= 5 then
            mon_set = {"rat"
             }
        elseif round <= 10 then
            mon_set = {"rat"
            }
        elseif round <= 15 then
            mon_set = {"rat"
            }
        elseif round <= 20 then
            mon_set = {"rat"
            }
        elseif round <= 26 then
            mon_set = {"rat"
            }
        elseif round <= 36 then
            mon_set = {"rat"
            }
        else -- Because somehow, the above stuff was too easy.
            mon_set = {"rat"
            }
        end

        local picked = crawl.random2(#mon_set) + 1
        crawl.dpr("Picking monster set " .. picked .. " of " .. #mon_set .. ": " ..
                  mon_set[picked])

        return {mon_set[picked]}
    else
        local which_boss = math.floor(math.min(round, 27) / 5)
        if round >= 27 then
            which_boss = which_boss + math.floor((round - 27) / 3)
        end
        return dgn.persist.arena_sprint_boss_set[which_boss]
    end
end


function arena_sprint_init_boss_table()
    -- This is called once when the map is loaded, and pre-determines the order
    -- of boss matches.
    --
    -- For the first two fights, there are five possible bosses per rune. The
    -- next three have two possible per rune. The rest just have one (but the
    -- order is random). The reason for doing it this way is because the early
    -- bosses will be the ones you see the most often, so they call for the
    -- most variety.

    local bs = {}
    if crawl.coinflip() then
        bs[1] = {"place:Workshop", "aizul hd:7 hp:120 / " ..
                 "naga warrior name:naga_warlord n_rpl n_des n_noc col:cyan hp:130 / " ..
                 "anaconda name:giant n_adj n_noc hp:130 col:lightred",
                 "serpentine rune of zot"}
    else
        bs[1] = {"place:Storage", "the lernaean hydra / " ..
                 "wizard name:witch n_rpl n_des n_noc col:green hp:130 " ..
                   "spells:mephitic_cloud.15.wizard;" ..
                          "summon_hydra.15.wizard;" ..
                          "invisibility.15.wizard;" ..
                          "blink_away.15.wizard.emergency",
                 "decaying rune of zot"}
    end

    if crawl.coinflip() then
        bs[2] = {"place:Forge", "arachne hp:250 / " ..
                 "wolf spider name:dire n_adj n_noc col:blue hp:300 / " ..
                 "jumping spider name:phase_spider n_rpl n_des never_corpse " ..
                    "col:lightgreen spells:blink_away.58.natural hp:300",
                 "gossamer rune of zot"}
    else
        bs[2] = {"place:Shoals", "polyphemus hp:350 / ilsuiw hp:250 / " ..
                 "merfolk avatar name:dimme tile:mons_dimme n_rpl n_des n_spe " ..
                    "col:lightmagenta hp:300 spells:avatar_song.160.natural;" ..
                                                   "malign_gateway.40.natural",
                 "barnacled rune of zot"}
    end

    if crawl.coinflip() then
        -- Elementalist boss is from mu_elemental_laboratory
        bs[3] = {"place:Tower w:300 / deep elf sorcerer / deep elf blademaster / " ..
                 "deep elf master archer / deep elf annihilator / deep elf high priest",
                 "fannar hp:400 hd:14 / " ..
                 "deep elf elementalist hp:400 " ..
                    "; robe ego:fire_resistance | " ..
                    "robe ego:cold_resistance | " ..
                    "robe ego:resistance . dagger ego:freezing | " ..
                    "dagger ego:flaming | dagger ego:electrocution",
                 "elven rune of zot"}
    else
        bs[3] = {"place:Forest:$ w:50 / spriggan druid w:2 / spriggan air mage w:5 / " ..
                 "spriggan berserker w:5", "agnes hp:335",
                 "mossy rune of zot"}
    end

    bs[4] = {"place:Slime", "dissolution hp:430 / " ..
             "acid blob name:sulfuric n_adj col:white hp:450 / " ..
             "great orb of eyes name:greater_orb_of_eyes n_rpl n_des n_noc col:green hp:600",
             "slimy rune of zot"}
    bs[5] = {"vault guard / place:Fortress", "mennas hp:250 / mara hp:300 / " ..
             "vault guard name:captain n_suf n_noc col:lightcyan hp:800 hd:26",
             "silver rune of zot"}
    if crawl.coinflip() then
        bs[5], bs[4] = bs[4], bs[5]
    end

    bs[6] = {"place:Dis:$", "dispater", "iron rune of zot"}
    bs[7] = {"place:Tar:$", "ereshkigal", "bone rune of zot"}
    bs[8] = {"place:Geh:$", "asmodeus", "obsidian rune of zot"}
    bs[9] = {"place:Coc:$", "antaeus", "icy rune of zot"}
    -- Pan sets are based on those in pan.des
    bs[10] = {"neqoxec / cacodemon / tormentor / tentacled monstrosity / " ..
              "golden eye / eye of devastation / " ..
              "shining eye", "mnoleg", "glowing rune of zot"}
    bs[11] = {"smoke demon / blizzard demon / green death / rakshasa / " ..
              "glowing orange brain / titan / lich / draconian annihilator / " ..
              "deep elf annihilator", "lom lobon", "magical rune of zot"}
    bs[12] = {"efreet / sun demon / ynoxinul / balrug / brimstone fiend",
              "cerebov", "fiery rune of zot"}
    bs[13] = {"soul eater / executioner / shadow wraith",
              "gloorx vloq", "dark rune of zot"}
    bs[14] = {"guardian mummy w:15 / mummy priest w:3 / royal mummy w:2",
               "khufu hp:500", "golden rune of zot"}
    -- Shuffle the above 9. We only wind up using 6 through 9
    for i = 14, 7, -1 do
        local r = crawl.random_range(6, i)
        bs[i], bs[r] = bs[r], bs[i]
    end

    -- Final (and tenth) boss
    bs[10] = {"pandemonium lord",
              "ancient lich name:Master_Blaster n_rpl hd:30 hp:1500 col:lightmagenta " ..
              "spells:fire_storm.32.wizard;glaciate.16.wizard;miasma_breath.16.wizard;blink_away.16.wizard.emergency", "demonic rune of zot"}
    return bs
end


function thing_do_arena(data, triggerable, triggerer, marker, ev)

    if data.finished then
        return
    end

    -- Count kills
    if triggerer.type == "monster_dies" and not data.between_rounds then
        local mons = dgn.mons_from_mid(ev:arg1())
        if mons.has_prop("arena_replica") then
            data.num_killed = data.num_killed + 1
        elseif mons.has_prop("boss_mons") then
            data.num_killed = data.round_enemies
        end
        if data.num_killed >= data.round_enemies then
            -- You win.
            arena_sprint_end_round(data)
        end
        return
    end

    -- Pause the timer if you use step from time.
    if you.pos() == 0 then
        return
    end

    -- Pause if you've been banished to the Abyss, or are otherwise absent for
    -- more than 10 turns, somehow.
    if ev:ticks() >= 100 then
        return
    end

    if triggerer.type == "turn" and triggerer.sub_type == "countdown" then
        if data.between_rounds then
            data.time_left = data.time_left - 1
            arena_sprint_ominous_countdown(data.time_left, data.between_rounds)

            if data.time_left <= 0 then
                crawl.take_note("Round " .. data.round_id .. ".")
                crawl.mpr("ROUND " .. data.round_id .. "!", "warning")
                if data.round_id == 42 then
                    crawl.mpr("FINAL BOSS!", "warning")
                elseif arena_sprint_is_boss_round(data.round_id) then
                    crawl.mpr("BOSS ROUND!", "warning")
                elseif data.round_id == 27 then
                    crawl.mpr("ZOT ROUND!", "orb")
                else
                    crawl.mpr("FIGHT!", "warning")
                end

                data.time_left = 510 + crawl.random2(200)

                -- Non-boss rounds have more enemies, and a more random amount
                data.round_enemies = 5 + crawl.div_rand_round(data.round_id, 3)
                if not arena_sprint_is_boss_round(data.round_id) then
                    data.round_enemies = data.round_enemies + crawl.random2(crawl.div_rand_round(data.round_id, 3))
                end
                crawl.dpr("Number to spawn: " .. data.round_enemies .. ".")

                -- 1/5 chance of a normal round being a lightning round
                data.lightning_round = false
                if data.round_id ~= 27 and data.round_id ~= 1 and crawl.one_chance_in(5)
                    and not arena_sprint_is_boss_round(data.round_id)
                then
                    data.spawn_rate = 1
                    data.lightning_round = true
                    crawl.mpr("LIGHTNING ROUND!", "warning")
                else
                    data.spawn_rate = math.ceil((1000 + crawl.random2(500)) / data.round_enemies)
                end
                crawl.dpr("Spawn rate: " .. data.spawn_rate .. ".")
                data.spawn_timer = 0

                data.num_killed = 0
                data.num_spawned = 0
                data.boss_spawned = false
                data.monster_set = arena_sprint_get_monster_set(data.round_id,
                                                                arena_sprint_is_boss_round(data.round_id))

                if data.round_id > 27 then
                    local p = dgn.find_marker_positions_by_prop("centre_point", 1)[1]
                    if feat.is_stair(p.x, p.y) then
                        dgn.grid(p.x, p.y, "floor")
                        crawl.mpr("The exit has been sealed! It will re-open when you get the next rune.")
                    end
                end

                -- 50% chance of picking a specific direction to spawn from, else
                -- spawn from all four directions.
                if crawl.coinflip() then
                    local directions = {"north", "east", "south", "west"}
                    data.spawn_dir = directions[crawl.random2(#directions) + 1]
                    crawl.mpr("You sense a tension in the " .. data.spawn_dir .. ".")
                else
                    data.spawn_dir = "spawn_point"
                end

                data.between_rounds = false
            end
        else -- Active round
            if data.num_spawned >= data.round_enemies or data.spawn_timer > 3000 then
                -- Final countdown... starts at just above 50 turns to go. Triggers
                -- when all enemies spawn or when 300 turns is passed. The latter
                -- mainly happens when the portals get blocked.
                data.time_left = data.time_left - 1
                arena_sprint_ominous_countdown(data.time_left, data.between_rounds)
            else
                data.spawn_timer = data.spawn_timer + 1
                -- If the round takes more than 100 turns, speed things up a lot
                if data.spawn_timer > 1000 and data.spawn_rate > 1 then
                    data.spawn_rate = data.spawn_rate - 1
                    crawl.dpr("Speeding up...")
                end
            end

            if data.spawn_timer % data.spawn_rate == 0 or data.num_spawned == 0 then
                arena_sprint_spawn_enemies(data)
            end

            if data.time_left <= 0 then
                arena_sprint_end_round(data)
            end
        end
    end
end

-- Should return two values: the score, and false to indicate that we
-- don't want to add the default score.
function arena_sprint_score (won)
    local points = dgn.persist.arena_style_points
    local runes = you.num_runes()

    if won and runes > 0 then
        points = points * runes
    end
    return points, false
end

}}

NAME:       arena_sprint
TAGS:       sprint no_item_gen no_trap_gen no_rotate no_hmirror no_vmirror
DESC:       Sprint VI: "Thunderdome"
ORDER:      6
ORIENT:     encompass
LROCKTILE:  wall_hall
{{
    -- Yes, 15 is the same as the normal game but it's nice to be explicit
    -- in Sprint maps since they don't typically place exactly 15.
    crawl.set_max_runes(15)

    local arena_marker = TriggerableFunction:new {
        data = {
            num_killed = 0,
            num_spawned = 0,
            boss_spawned = false,
            round_id = 1,
            round_enemies = 0,      -- How many you need to fight
            spawn_rate = 0,
            spawn_timer = 0,        -- Counter for monster spawning
            lightning_round = false,
            time_left = 60,         -- How much time is left
            between_rounds = true,  -- Are we waiting for the next round?
            finished = false,       -- You somehow beat round 42
            monster_set = {},
            style_mult = 1,
            spawn_dir = ""          -- Which spawn points to use?
        },
        func = "thing_do_arena",
        repeated = true
    }

    arena_marker:add_triggerer(DgnTriggerer:new {
        type = "monster_dies",
        -- Note: target is "any", but we don't do anything unless it has
        -- the "arena_replica" or "boss_mons" property
        target = "any"
    })

    arena_marker:add_triggerer(DgnTriggerer:new {
        type = "turn",
        delay = 1
    })

    dgn.persist.arena_sprint_boss_set = arena_sprint_init_boss_table()

    -- Storing this in dgn.persist rather than arena_marker.data so that
    -- arena_sprint_score can access it.
    dgn.persist.arena_style_points = 0
    dgn.persist.calc_score = global_function("arena_sprint_score");

    lua_marker("{", arena_marker)
    lua_marker("{", portal_desc { centre_point = 1 })
    lua_marker("T", portal_desc { spawn_point = 1, north = 1 })
    lua_marker("U", portal_desc { spawn_point = 1, east = 1 })
    lua_marker("V", portal_desc { spawn_point = 1, south = 1 })
    lua_marker("W", portal_desc { spawn_point = 1, west = 1 })
    lua_marker("Y", portal_desc { spawn_point = 1, north = 1, west = 1 })
    lua_marker("Z", portal_desc { spawn_point = 1, north = 1, east = 1 })
    lua_marker("!", portal_desc { spawn_point = 1, south = 1, west = 1 })
    lua_marker("?", portal_desc { spawn_point = 1, south = 1, east = 1 })

    set_feature_name("dry_fountain", "spawn point")

    crawl.mpr("<cyan>You have entered the arena!\n" ..
              "You will win if you kill everything that spawns (including allies).\n" ..
              "If it is a boss round, you only need to kill the boss in order to win.\n" ..
              "If it is a lightning round, you only need to survive!</cyan>")
}}
# No exploration gods. Positions are random, and you don't have enough time to
# reach an altar before the game starts.
# NB: At present, there are 24 slots in the map, that's enough to take
# us to up to 'u'; if you want more you'll have to rejigger the map.
NSUBST: B = 0 / 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8 / 9 / h / i / j / k / l / \
            m / n / o / p / q / *:.
KFEAT:  0 = altar_zin
KFEAT:  1 = altar_the_shining_one
KFEAT:  2 = altar_lugonu
KFEAT:  3 = altar_kikubaaqudgha
KFEAT:  4 = altar_yredelemnul
KFEAT:  5 = altar_xom
KFEAT:  6 = altar_vehumet
KFEAT:  7 = altar_okawaru
KFEAT:  8 = altar_makhleb
KFEAT:  9 = altar_sif_muna
KFEAT:  h = altar_trog
KFEAT:  i = altar_beogh
KFEAT:  j = altar_cheibriados
KFEAT:  k = altar_fedhas
KFEAT:  l = altar_dithmenos
KFEAT:  m = altar_gozag
KFEAT:  n = altar_qazlal
KFEAT:  o = altar_ru
KFEAT:  p = altar_uskayaw
KFEAT:  q = altar_wu_jian
KITEM:  { = scroll of blinking q:3, scroll of fog q:3, \
            potion of heal wounds q:3, potion of haste q:3, \
            any blast wand charges:5, \
            any beam wand charges:5, \
            potion of resistance, gold q:200
KFEAT:  { = {
SUBST:  b : cb
TILE:   c = wall_marble
KFEAT:  TUVWYZ!? = dry_fountain
TILE:   TUVWYZ!? = floor_black_cobalt
COLOUR: TUVWYZ!? = magenta
MAP
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXcccccXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXccTTTccXXXXXXXXXXXXXX
XXXXXXXXXXXXXXc.....cXXXXXXXXXXXXXX
XXXXXXXXXXXXXcc.....ccXXXXXXXXXXXXX
XXXXXXXXXXXXccP.....DccXXXXXXXXXXXX
XXXXXXXXXXXXcE.......NcXXXXXXXXXXXX
XXXXXXXXXXXXcB.......BcXXXXXXXXXXXX
XXXXXXXXXXXXcB.......BcXXXXXXXXXXXX
XXXXXXXXXXXccB.......BcXXXXXXXXXXXX
XXXXXXXXXXccc.........cccXXXXXXXXXX
XXXXXXXXXXcY...........ZcXXXXXXXXXX
XXXXXcccccc.G.........G.ccccccXXXXX
XXXXccMBBB......xxx......BBBFccXXXX
XXcccI........G.xxx.G........ScccXX
Xcc.............xxx.............ccX
XcW..........xxx...xxx..........UcX
XcW..........xxx.{.xxx..........UcX
XcW..........xxx...xxx..........UcX
Xcc.............xxx.............ccX
XXcccK........G.xxx.G........HcccXX
XXXXccCBBB......xxx......BBBOccXXXX
XXXXXcccccc.G.........G.ccccccXXXXX
XXXXXXXXXXc!...........?cXXXXXXXXXX
XXXXXXXXXXccc.........cccXXXXXXXXXX
XXXXXXXXXXXXcB.......BcXXXXXXXXXXXX
XXXXXXXXXXXXcB.......BcXXXXXXXXXXXX
XXXXXXXXXXXXcB.......BcXXXXXXXXXXXX
XXXXXXXXXXXXcR.......QcXXXXXXXXXXXX
XXXXXXXXXXXXccJ.....LccXXXXXXXXXXXX
XXXXXXXXXXXXXcc.....ccXXXXXXXXXXXXX
XXXXXXXXXXXXXXccVVVccXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXcccccXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
ENDMAP
